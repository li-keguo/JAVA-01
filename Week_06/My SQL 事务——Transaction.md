# My SQL 事务——Transaction

## 事务定义

- 事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)
- 一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成
- 事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同

## 事务特性

#### ACID

- 原子性(Atomicicy)：事务是最小单位，不可再分
- 一致性(Consistency)：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败
- 隔离性(Isolation)：事务A和事务B之间具有隔离性
- 持久性(Durability)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)

#### 隔离性

1. 事物A和事物B之间具有一定的隔离性

2. 隔离性有隔离级别(4个)

   - 读未提交：read uncommitted

     - ```sql
       - 事物A和事物B，事物A未提交的数据，事物B可以读取到
       - 这里读取到的数据叫做“脏数据”
       - 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别
       ```

   - 读已提交：read committed

     - ```sql
       - 事物A和事物B，事物A提交的数据，事物B才能读取到
       - 这种隔离级别高于读未提交
       - 换句话说，对方事物提交之后的数据，我当前事物才能读取到
       - 这种级别可以避免“脏数据”
       - 这种隔离级别会导致“不可重复读取”
       - Oracle默认隔离级别
       ```

   - 可重复读：repeatable read

     - ```sql
       - 事务A和事务B，事务A提交之后的数据，事务B读取不到
       - 事务B是可重复读取数据
       - 这种隔离级别高于读已提交
       - 换句话说，对方提交之后的数据，我还是读取不到
       - 这种隔离级别可以避免“不可重复读取”，达到可重复读取
       - 比如1点和2点读到数据是同一个
       - MySQL默认级别
       - 虽然可以达到可重复读取，但是会导致“幻像读”
       ```

   - 串行化：serializable

     - ```sql
       - 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
       - 这种隔离级别很少使用，吞吐量太低，用户体验差
       - 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发
       ```

|                      | 脏读 | 不可重复读 | 幻读        |
| -------------------- | ---- | ---------- | ----------- |
| 读未提交             | ✔    | ✔          | ✔           |
| 读已提交             | ✘    | ✔          | ✔           |
| 可重复度(InnoDB默认) | ✘    | ✘          | ✘(InnoDB) ✔ |
| 串行化               | ✘    | ✘          | ✘           |

- **脏读**: 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
- **不可重复读**:是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
- **幻读**:第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样，幻读是数据行记录变多了或者少了。

##### 设置隔离级别

- 使用命令

  - ```sql
    --	READ UNCOMMITTED
    --	READ COMMITTED
    --	REPEATABLE READ
    --	SERIALIZABLE
    
    -- 会话级
    SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
    -- 全局级
    SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
    ```

- 修改配置（my.ini）

  - ```sql
    --	READ UNCOMMITTED
    --	READ COMMITTED
    --	REPEATABLE READ
    --	SERIALIZABLE
    transaction-isolation = READ-COMMITTED
    ```

#### 锁

- 共享锁（S）
- 排它锁（X）
- 意向锁 —— 上锁前先上意向锁：表明事务稍后将进行某些类型的锁定
  - 共享意向锁（IS）：表明将在某些行设置共享锁
  - 排他意向锁（IX）：表明将在某些行设置排他锁
  - Insert意向锁
- 其他
  - 自增锁（Auto-In）
  - Lock Table/DDL

|                  | 排他锁（X） | 排他意向锁（IX） | 共享锁 （S） | 共享意向锁（IS） |
| ---------------- | ----------- | ---------------- | ------------ | ---------------- |
| 排它锁（X）      | 冲突        | 冲突             | 冲突         | 冲突             |
| 排他意向锁（IX） | 冲突        | **兼容**         | 冲突         | **兼容**         |
| 共享锁（S）      | 冲突        | 冲突             | **兼容**     | **兼容**         |
| 共享意向锁（IS） | 冲突        | **兼容**         | **兼容**     | **兼容**         |



## 事务使用

```sql
start transaction;
insert or update ...
commit; or rollback;
```



## 事务实现

### redo log 和 undo log

#### undo log：

为了实现事务原子性，要么全部完成commit，要么全部回滚rollback，Innodb用于实现mvcc（多版本并发控制）
例如：将user=’A’ 改为 user=’B’，则undo log中会记录下user=’A’和事务版本等信息
一旦事务完成，所有修改必须被记录下，保证数据一致性（后面redo log解释）

#### redo log：

如果使用undo log作为持久化数据，意味着修改数据和undo log必须同时写入磁盘持久化，这必定带来巨大的磁盘io，解决方案为了平衡磁盘io和一致性，引入redo log。
数据和undo log可定时从缓冲刷至磁盘，但是redo log必须实时写入磁盘，当系统奔溃时，可依据redo log进行数据重做。
InnoDB存储引擎层的日志。

```
事务的简化过程
假设有A、B两个数据，值分别为1,2，现在修改为3、4
1. 事务开始。
2. 记录A=1到undolog。
3. 修改A=3。
4. 记录A=3到redolog。
5. 记录B=2到undolog。
6. 修改B=4。
7. 记录B=4到redolog，将redolog写入磁盘。
8. 事务提交。

```

### bin log和relay log

#### bin log：

redo log可以实现数据重做，那为什么要使用binlog？因为redo log是Innodb实现的物理日志，一旦涉及到多种存储引擎，无法进行重做。
bin log 记录下所有数据的更改，可用于本机数据恢复和主从同步。
刷入磁盘的方式：每个1s刷入磁盘 | 每次事务提交刷入磁盘 | 每个1s刷入磁盘+每次事务提交刷入磁盘
参考链接

#### relay（中继） log：

Mysql 主节点将binlog写入本地，从节点定时请求增量binlog，主节点将binlog同步到从节点。
从节点单独进程会将binlog 拷贝至本地 relaylog中。
从节点定时重放relay log。
